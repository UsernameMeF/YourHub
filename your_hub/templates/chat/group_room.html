{% extends 'base.html' %}
{% load static %}

{% block title %}Группа: {{ group_chat.name }}{% endblock %}

{% block extra_head %}
    {# Стили для страницы комнаты чата #}
    <link rel="stylesheet" href="{% static 'css/chat/_chat_room.css' %}">
    <link rel="stylesheet" href="{% static 'css/chat/_chat_room_dark.css' %}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
{% endblock %}

{% block content %}
<div class="chat_room-container"
     data-chat-type="group" {# Теперь всегда 'group' #}
     data-chat-id="{{ group_chat.id }}"> {# ID группового чата #}
    <h1>
        <div class="chat_header-left-elements">
            <a href="{% url 'chat:chat_list' %}" class="chat_back-button" title="Назад к чатам"><i class="fas fa-arrow-left"></i></a>
        </div>

        {# Заголовок чата: название группы #}
        <span class="chat_header-name"><i class="fas fa-users"></i> {{ group_chat.name }}ㅤ</span> {# Невидимый символ для пробела #}
        <div class="group-participants-count">
            {{ group_chat.participants.count }} участник{{ group_chat.participants.count|pluralize:"а,ов" }}
        </div>
        {# Можно добавить ссылку на информацию о группе: <a href="{% url 'chat:group_info' group_chat.id %}">Подробнее</a> #}

        <div id="typing-indicator" style="display: none; font-style: italic; color: gray; margin-top: -30px; margin-bottom: 5px; text-align: center;"></div>
    </h1>

    <div id="chat_log" class="chat_log">
        {% for message in messages %}
            <div class="chat_message-item {% if message.sender == request.user %}my_message{% else %}other_message{% endif %}"
                 data-message-id="{{ message.id }}"
                 data-read-by-current="{% if message.sender == request.user or request.user in message.read_by.all %}true{% else %}false{% endif %}">
                <div class="chat_message-header">
                    {# В групповом чате всегда показываем имя отправителя, если это не текущий пользователь #}
                    {% if message.sender != request.user %}
                        <span class="chat_sender-username group_chat_sender">{{ message.sender.username }}</span>
                    {% else %}
                        <span class="chat_sender-username">Вы</span>
                    {% endif %}
                    <span class="chat_message-timestamp">{{ message.timestamp|date:"d.m.Y H:i" }}</span>
                    {% if message.is_edited %}
                        <span class="chat_edited-status">(отредактировано)</span>
                    {% endif %}
                </div>
                <div class="chat_message-content-wrapper">
                    <div class="chat_message-content">{{ message.content|linebreaksbr }}
                        {% for attachment in message.attachments.all %}
                            <div class="chat_attachment-item" data-attachment-id="{{ attachment.id }}">
                                {% if attachment.file_type == 'image' %}
                                    <img src="{{ attachment.file.url }}" alt="{{ attachment.original_filename }}" class="chat_image" onclick="window.open(this.src)">
                                {% elif attachment.file_type == 'video' %}
                                    <video controls class="chat_video">
                                        <source src="{{ attachment.file.url }}" type="video/mp4">
                                        Ваш браузер не поддерживает видео тег.
                                    </video>
                                {% elif attachment.file_type == 'document' %}
                                    <a href="{{ attachment.file.url }}" target="_blank" class="chat_document-link">
                                        <i class="fas fa-file-alt"></i> {{ attachment.original_filename }}
                                    </a>
                                {% endif %}
                            </div>
                        {% endfor %}
                    </div>
                    {# ИНДИКАТОР ПРОЧТЕНИЯ для группового чата #}
                    {% if message.sender == request.user %}
                        <div class="chat_read-status" data-read-count="{{ message.read_by.count }}">
                            {% if message.read_by.count > 1 %} {# Если прочитан отправителем и хотя бы одним другим #}
                                <i class="fas fa-check-double"></i> <span>{{ message.read_by.count }}</span>
                            {% else %} {# Прочитано только отправителем #}
                                <i class="fas fa-check"></i>
                            {% endif %}
                        </div>
                    {% endif %}
                </div>
                {# Кнопки редактирования/удаления #}
                {% if message.sender == request.user %}
                <div class="chat_message-actions">
                    <button class="chat_edit-button btn btn-sm btn-info" data-message-id="{{ message.id }}"><i class="fas fa-edit"></i> Редактировать</button>
                    <button class="chat_delete-button btn btn-sm btn-danger" data-message-id="{{ message.id }}"><i class="fas fa-trash"></i> Удалить</button>
                </div>
                {% endif %}
            </div>
        {% empty %}
            <p class="chat_no-messages">Пока нет сообщений в этой группе. Начните общение!</p>
        {% endfor %}
    </div>

    <div class="chat_input-area">
        <textarea id="chat_message-input" placeholder="Введите ваше сообщение..." rows="3"></textarea>
        <div class="chat_attachments-preview" id="chat_attachments-preview">
            {# Здесь будут отображаться предпросмотры выбранных файлов #}
        </div>
        <div class="chat_actions">
            <input type="file" id="chat_file-input" multiple hidden accept="image/*,video/*,.pdf,.doc,.docx,.xls,.xlsx,.txt">
            <button id="chat_attach-file-button" class="btn btn-secondary"><i class="fas fa-paperclip"></i> Прикрепить</button>
            <button id="chat_message-submit" class="btn btn-primary">Отправить</button>
            <button id="chat_cancel-edit-button" class="btn btn-warning" style="display: none;">Отмена</button>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
{# Скрытые элементы для передачи данных из Django в JavaScript #}
<div id="room-id" data-room-id="{{ group_chat.id }}" style="display: none;">{{ group_chat.id|json_script:"room-id" }}</div>
<div id="current-user-id" data-current-user-id="{{ request.user.id }}" style="display: none;">{{ request.user.id|json_script:"current-user-id" }}</div>
{# ДОБАВЛЕНО: Передаем количество участников чата для логики JS #}
<div id="chat-participants-count" data-count="{{ group_chat.participants.count }}" style="display: none;"></div>

<div class="chat_room-container"
    data-chat-type="group"
    data-chat-id="{{ group_chat.id }}">


    <script id="room-id-data" type="application/json">{{ group_chat.id }}</script>
    <script id="room-type-data" type="application/json">"group"</script> 

    <h1>
        </h1>
    </div>

<script>
    // Получаем room_id из контекста Django
    const roomId = JSON.parse(document.getElementById('room-id-data').textContent);
    const roomType = JSON.parse(document.getElementById('room-type-data').textContent); 

    // Добавление current_user_username для сравнения
    const current_user_username = "{{ request.user.username|escapejs }}";
    const currentUserId = "{{ request.user.id }}";
    // Получаем количество участников чата
    const chatParticipantsCount = parseInt(document.getElementById('chat-participants-count').dataset.count);

    // Получаем элементы DOM
    const chatLog = document.getElementById('chat_log');
    const messageInput = document.getElementById('chat_message-input');
    const messageSubmit = document.getElementById('chat_message-submit');
    const fileInput = document.getElementById('chat_file-input');
    const attachFileButton = document.getElementById('chat_attach-file-button');
    const attachmentsPreview = document.getElementById('chat_attachments-preview');
    const cancelEditButton = document.getElementById('chat_cancel-edit-button');

    
    // Переменная для хранения ID редактируемого сообщения
    let editingMessageId = null;
    // Переменная для хранения исходных вложений редактируемого сообщения (их URL-ы)
    let originalAttachments = []; // Это не используется, можно удалить или пересмотреть

    // Элементы для индикатора "печатает..."
    const typingStatusContainer = document.getElementById('typing-indicator');
    let typingTimeout = null;
    let isTypingLocally = false;
    const typingUsers = new Set();

    let selectedFiles = []; // Для новых файлов, которые будут загружены
    let currentAttachments = []; // Для файлов, которые уже прикреплены к сообщению (для редактирования)

    // WebSocket-соединение
    const chatSocket = new WebSocket(
        'ws://127.0.0.1:8001/chat/'
        + roomType + '/'           // ВОТ ЭТО ДОЛЖНО ПРИСУТСТВОВАТЬ
        + roomId + '/'
    );

    // --- Логика статуса "просмотрено" ---

    // Set для хранения ID сообщений, которые уже были отмечены как прочитанные текущим пользователем
    const readMessagesCache = new Set();

    const intersectionObserverOptions = {
        root: chatLog, // Наблюдаем за сообщениями внутри chatLog
        rootMargin: '0px', // Отступ от краев chatLog
        threshold: 0.8 // Сообщение считается видимым, если 80% его площади видно
    };

    const messageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) { // Если элемент вошел в область видимости
                const messageElement = entry.target;
                const messageId = messageElement.dataset.messageId;
                // Проверяем, что сообщение не отправлено текущим пользователем
                // И что оно еще не помечено как прочитанное текущим пользователем
                if (messageElement.classList.contains('other_message') && !readMessagesCache.has(messageId) && chatSocket.readyState === WebSocket.OPEN) {
                    console.log(`Message ${messageId} is visible and not read by current user. Sending read_receipt.`);
                    chatSocket.send(JSON.stringify({
                        'type': 'read_receipt',
                        'message_id': messageId
                    }));
                    readMessagesCache.add(messageId); // Добавляем в кэш, чтобы не отправлять повторно
                    // Опционально: можно отменить наблюдение за этим сообщением, если оно больше не нужно
                    // observer.unobserve(messageElement);
                }
            }
        });
    }, intersectionObserverOptions);

    // Функция для добавления нового сообщения в Observer
    function addMessageToObserver(messageElement) {
        // Мы хотим наблюдать только за сообщениями, отправленными ДРУГИМИ пользователями
        // и которые еще не были помечены как прочитанные текущим пользователем
        if (messageElement.classList.contains('other_message') && messageElement.dataset.readByCurrent === 'false') {
            messageObserver.observe(messageElement);
        }
    }

    // Инициируем наблюдение за уже существующими сообщениями при загрузке
    function observeMessagesForReadReceipts() {
        const messages = chatLog.querySelectorAll('.chat_message-item');
        messages.forEach(messageElement => {
            // Добавляем в кэш все сообщения, которые уже помечены как прочитанные отправителем или мной
            if (messageElement.dataset.readByCurrent === 'true') {
                readMessagesCache.add(messageElement.dataset.messageId);
            }
            addMessageToObserver(messageElement);
        });
    }

    // --- Обработчики событий WebSocket ---

    chatSocket.onopen = function(e) {
        console.log('WebSocket connected');
        scrollToBottom();
        // При подключении, сразу инициируем проверку видимости сообщений для прочтения
        observeMessagesForReadReceipts();
    };

    chatSocket.onclose = function(e) {
        console.error('WebSocket closed unexpectedly:', e);
        // Очистить observer при закрытии соединения
        messageObserver.disconnect(); // Отключаем observer при закрытии сокета
    };

    chatSocket.onmessage = function(e) {
        const data = JSON.parse(e.data);
        console.log('Received message:', data);

        if (data.type === 'chat_message') {
            const newMessageElement = createMessageElement({
                id: data.message_id,
                sender_id: data.sender_id,
                sender_username: data.sender_username,
                sender_avatar_url: data.sender_avatar_url,
                content: data.message,
                timestamp: data.timestamp,
                attachments: data.attachments || [],
                read_count: data.read_count || 0,
                is_edited: data.is_edited || false
            });
            chatLog.appendChild(newMessageElement);
            scrollToBottom();
            // Начинаем наблюдать за новым сообщением
            addMessageToObserver(newMessageElement);
            addMessageActionListeners(newMessageElement); // Добавляем слушатели для новых сообщений
        } else if (data.type === 'typing_status') {
            handleTypingStatus(data.username, data.is_typing);
        } else if (data.type === 'read_receipt_notification') {
            handleReadReceiptNotification(data.message_id, data.reader_id, data.read_count);
        } else if (data.type === 'message_edited') {
            handleMessageEdited(data.message_id, data.new_content, data.attachments); // Передаем вложения
        } else if (data.type === 'message_deleted') {
            handleMessageDeleted(data.message_id);
        }
    };

    chatSocket.onerror = function(e) {
        console.error('WebSocket error:', e);
    };

    // --- Функции для отображения сообщений (ОБНОВЛЕННАЯ) ---

    function createMessageElement(message) {
        const messageClass = message.sender_id == currentUserId ? 'my_message' : 'other_message';
        const messageElement = document.createElement('div');
        messageElement.classList.add('chat_message-item', messageClass);
        messageElement.dataset.messageId = message.id; // Добавляем data-атрибут для ID сообщения
        // Устанавливаем data-read-by-current при создании элемента
        messageElement.dataset.readByCurrent = message.sender_id == currentUserId || (message.read_count > 0 && message.sender_id != currentUserId) ? 'true' : 'false';

        let attachmentsHtml = '';
        let attachmentsData = []; // Для хранения данных вложений, чтобы можно было их загрузить для редактирования
        if (message.attachments && message.attachments.length > 0) {
            attachmentsHtml += '<div class="chat_attachments-wrapper">'; // Используем новый класс для обертки вложений
            message.attachments.forEach(function(attachment) {
                const attachmentFileName = attachment.original_filename || attachment.file_url.split('/').pop();
                attachmentsData.push({
                    id: attachment.id, // Добавляем ID вложения
                    file_url: attachment.file_url,
                    file_type: attachment.file_type,
                    original_filename: attachmentFileName
                });

                if (attachment.file_type === 'image') {
                    attachmentsHtml += `<div class="chat_attachment-item"><a href="${attachment.file_url}" target="_blank"><img src="${attachment.file_url}" alt="Вложение" class="chat_image" onclick="window.open(this.src)"></a></div>`;
                } else if (attachment.file_type === 'video') {
                    attachmentsHtml += `<div class="chat_attachment-item"><video controls class="chat_video"><source src="${attachment.file_url}" type="video/mp4">Ваш браумер не поддерживает видео тег.</video></div>`;
                } else {
                    attachmentsHtml += `<div class="chat_attachment-item"><a href="${attachment.file_url}" target="_blank" class="chat_document-link"><i class="fas fa-file-alt"></i> ${attachmentFileName}</a></div>`;
                }
            });
            attachmentsHtml += '</div>';
        }
        messageElement.dataset.attachments = JSON.stringify(attachmentsData); // Сохраняем вложения в data-атрибут

        const senderDisplayName = message.sender_id == currentUserId ? 'Вы' : message.sender_username;
        const isMyMessage = message.sender_id == currentUserId;

        // Определяем HTML для статуса прочтения
        let readStatusHtml = '';
        if (isMyMessage) {
            const readCount = message.read_count || 0;
            let iconClass = 'fa-check'; // По умолчанию одна галочка
            let countSpan = '';

            // Логика для личных чатов (2 участника):
            if (chatParticipantsCount === 2) {
                if (readCount >= chatParticipantsCount) { // readCount = 2 (отправитель + 1 собеседник)
                    iconClass = 'fa-check-double';
                }
                // Для личных чатов не показываем цифру
                countSpan = '';
            } else { // Логика для группового чата (если chatParticipantsCount > 2)
                // Если у нас групповой чат, то две галочки, если прочитали более 1 человека
                // и показываем количество
                if (readCount > 1) {
                    iconClass = 'fa-check-double';
                    countSpan = `<span>${readCount}</span>`;
                }
            }

            readStatusHtml = `
                <div class="chat_read-status" data-read-count="${readCount}">
                    <i class="fas ${iconClass}"></i> ${countSpan}
                </div>`;
        }

        // HTML для статуса редактирования
        const editedStatusHtml = message.is_edited ? '<span class="chat_edited-status">(отредактировано)</span>' : '';

        messageElement.innerHTML = `
            <div class="chat_message-header">
                <span class="chat_sender-username">${senderDisplayName}</span>
                <span class="chat_message-timestamp">${message.timestamp}</span>
                ${editedStatusHtml}
            </div>
            <div class="chat_message-content-wrapper">
                ${message.content ? `<div class="chat_message-content">${message.content.replace(/\n/g, '<br>')}</div>` : ''}
                ${attachmentsHtml}
                ${readStatusHtml}
            </div>
            {# Кнопки редактирования/удаления #}
            ${isMyMessage ? `
            <div class="chat_message-actions">
                <button class="chat_edit-button btn btn-sm btn-info" data-message-id="${message.id}"><i class="fas fa-edit"></i> Редактировать</button>
                <button class="chat_delete-button btn btn-sm btn-danger" data-message-id="${message.id}"><i class="fas fa-trash"></i> Удалить</button>
            </div>` : ''}
        `;
        return messageElement;
    }

    function scrollToBottom() {
        // Проверяем наличие сообщений перед прокруткой, чтобы избежать ошибок на пустом чате
        if (chatLog.querySelector('.chat_message-item')) {
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    messageInput.addEventListener('input', function() {
        if (chatSocket.readyState === WebSocket.OPEN) {
            if (!isTypingLocally) {
                chatSocket.send(JSON.stringify({
                    'type': 'typing_status',
                    'is_typing': true
                }));
                isTypingLocally = true;
            }

            clearTimeout(typingTimeout);

            typingTimeout = setTimeout(() => {
                chatSocket.send(JSON.stringify({
                    'type': 'typing_status',
                    'is_typing': false
                }));
                isTypingLocally = false;
            }, 2000);
        }
    });

    function resetTypingStatus() {
        if (isTypingLocally) {
            clearTimeout(typingTimeout);
            if (chatSocket.readyState === WebSocket.OPEN) {
                chatSocket.send(JSON.stringify({
                    'type': 'typing_status',
                    'is_typing': false
                }));
            }
            isTypingLocally = false;
        }
    }

    function handleTypingStatus(username, isTyping) {
        if (username === current_user_username) {
            return;
        }

        if (isTyping) {
            typingUsers.add(username);
        } else {
            typingUsers.delete(username);
        }
        updateTypingIndicator();
    }

    function updateTypingIndicator() {
        if (typingUsers.size === 0) {
            typingStatusContainer.textContent = '';
            typingStatusContainer.style.display = 'none';
        } else {
            const usersList = Array.from(typingUsers).join(', ');
            typingStatusContainer.textContent = `${usersList} печатает...`;
            typingStatusContainer.style.display = 'block';
        }
    }

    // Функция для обработки уведомлений о прочтении от WebSocket
    function handleReadReceiptNotification(messageId, readerId, readCount) {
        const messageElement = chatLog.querySelector(`.chat_message-item[data-message-id="${messageId}"]`);
        if (messageElement) {
            // Обновляем статус прочтения только для СООБЩЕНИЙ, ОТПРАВЛЕННЫХ ТЕКУЩИМ ПОЛЬЗОВАТЕЛЕМ
            if (messageElement.classList.contains('my_message')) {
                const readStatusElement = messageElement.querySelector('.chat_read-status');
                if (readStatusElement) {
                    readStatusElement.dataset.readCount = readCount; // Обновляем data-атрибут
                    const icon = readStatusElement.querySelector('i');
                    let countSpan = readStatusElement.querySelector('span'); // Находим существующий span

                    // Логика для личных чатов (2 участника):
                    if (chatParticipantsCount === 2) {
                        if (readCount >= chatParticipantsCount) { // readCount = 2 (прочитано отправителем + собеседником)
                            icon.classList.remove('fa-check');
                            icon.classList.add('fa-check-double');
                            if (countSpan) { // Убеждаемся, что span отсутствует для личных чатов
                                countSpan.remove();
                            }
                        } else { // readCount = 1 (прочитано только отправителем)
                            icon.classList.remove('fa-check-double');
                            icon.classList.add('fa-check');
                            if (countSpan) {
                                countSpan.remove();
                            }
                        }
                    } else { // Логика для группового чата (если chatParticipantsCount > 2)
                        // Если у нас групповой чат, то две галочки, если прочитали более 1 человека
                        // и показываем количество
                        if (readCount > 1) {
                            icon.classList.remove('fa-check');
                            icon.classList.add('fa-check-double');
                            if (!countSpan) {
                                countSpan = document.createElement('span');
                                readStatusElement.appendChild(countSpan);
                            }
                            countSpan.textContent = readCount;
                        } else {
                            icon.classList.remove('fa-check-double');
                            icon.classList.add('fa-check');
                            if (countSpan) {
                                countSpan.remove();
                            }
                        }
                    }
                }
            }
        }
    }

    // --- Функции для редактирования и удаления сообщений ---

    // Обработчик события для отредактированного сообщения через WebSocket
    function handleMessageEdited(messageId, newContent, attachments) {
        const messageElement = chatLog.querySelector(`.chat_message-item[data-message-id="${messageId}"]`);
        if (messageElement) {
            const contentElement = messageElement.querySelector('.chat_message-content');
            if (contentElement) {
                // Обновляем текстовое содержимое
                contentElement.innerHTML = newContent.replace(/\n/g, '<br>');

                // Обновляем статус "отредактировано"
                let editedStatus = messageElement.querySelector('.chat_edited-status');
                if (!editedStatus) {
                    editedStatus = document.createElement('span');
                    editedStatus.classList.add('chat_edited-status');
                    messageElement.querySelector('.chat_message-header').appendChild(editedStatus);
                }
                editedStatus.textContent = '(отредактировано)';
            }
            // --- ЛОГИКА ОБНОВЛЕНИЯ ВЛОЖЕНИЙ ---
            const messageContentWrapper = messageElement.querySelector('.chat_message-content-wrapper'); // Контейнер, который содержит .chat_message-content и вложения

            // Находим существующий контейнер вложений, если он есть
            let attachmentsContainer = messageContentWrapper.querySelector('.chat_attachments-wrapper');

            // Удаляем все старые вложения и, возможно, их контейнер
            if (attachmentsContainer) {
                attachmentsContainer.innerHTML = ''; // Очищаем содержимое контейнера
            }

            // Если есть новые вложения, или если они были, но теперь их нет,
            // нужно управлять видимостью контейнера
            if (attachments && attachments.length > 0) {
                if (!attachmentsContainer) {
                    // Если контейнера не было, создаем его
                    attachmentsContainer = document.createElement('div');
                    attachmentsContainer.classList.add('chat_attachments-wrapper');
                    // Вставляем контейнер вложений после контента сообщения
                    if (contentElement) {
                        contentElement.after(attachmentsContainer);
                    } else {
                        messageContentWrapper.appendChild(attachmentsContainer);
                    }
                }

                attachments.forEach(attachment => {
                    const attachmentItem = document.createElement('div');
                    attachmentItem.classList.add('chat_attachment-item');
                    attachmentItem.dataset.attachmentId = attachment.id;

                    let innerHtml = '';
                    if (attachment.file_type === 'image') {
                        innerHtml = `<img src="${attachment.file_url}" alt="${attachment.original_filename}" class="chat_image" onclick="window.open(this.src)">`;
                    } else if (attachment.file_type === 'video') {
                        innerHtml = `<video controls class="chat_video"><source src="${attachment.file_url}" type="video/mp4">Ваш браузер не поддерживает видео тег.</video>`;
                    } else if (attachment.file_type === 'document') {
                        innerHtml = `<a href="${attachment.file_url}" target="_blank" class="chat_document-link"><i class="fas fa-file-alt"></i> ${attachment.original_filename}</a>`;
                    }
                    attachmentItem.innerHTML = innerHtml;
                    attachmentsContainer.appendChild(attachmentItem);
                });
            } else {
                // Если вложений нет, и контейнер существует, удаляем его
                if (attachmentsContainer) {
                    attachmentsContainer.remove();
                }
            }
            // --- КОНЕЦ ЛОГИКИ ОБНОВЛЕНИЯ ВЛОЖЕНИЙ ---
        }
    }

    // Обработчик события для удаленного сообщения через WebSocket
    function handleMessageDeleted(messageId) {
        const messageElement = chatLog.querySelector(`.chat_message-item[data-message-id="${messageId}"]`);
        if (messageElement) {
            messageElement.remove();
        }
        // Если чат стал пустым, показать сообщение "Пока нет сообщений..."
        if (chatLog.children.length === 0) {
            const noMessagesP = document.createElement('p');
            noMessagesP.classList.add('chat_no-messages');
            noMessagesP.textContent = 'Пока нет сообщений в этом чате. Начните общение!';
            chatLog.appendChild(noMessagesP);
        }
    }

    // Инициализация слушателей для кнопок редактирования/удаления
    function addMessageActionListeners(container) {
        const editButtons = container.querySelectorAll('.chat_edit-button');
        editButtons.forEach(button => {
            button.onclick = function() {
                const messageId = this.dataset.messageId;
                editMessage(messageId);
            };
        });

        const deleteButtons = container.querySelectorAll('.chat_delete-button');
        deleteButtons.forEach(button => {
            button.onclick = function() {
                const messageId = this.dataset.messageId;
                deleteMessage(messageId);
            };
        });
    }

    // Функция для начала редактирования сообщения
    async function editMessage(messageId) {
        const messageElement = chatLog.querySelector(`.chat_message-item[data-message-id="${messageId}"]`);
        if (!messageElement) return;

        editingMessageId = messageId;
        messageSubmit.textContent = 'Сохранить'; // Меняем текст кнопки
        cancelEditButton.style.display = 'inline-block'; // Показываем кнопку отмены
        attachFileButton.style.display = 'inline-block'; // Показываем кнопку прикрепления (если скрывалась)

        const messageContentElement = messageElement.querySelector('.chat_message-content');
        messageInput.value = messageContentElement ? messageContentElement.innerText : '';

        // Загружаем вложения для редактирования
        currentAttachments = JSON.parse(messageElement.dataset.attachments || '[]');
        // Создаем "фиктивные" File объекты из URL для отображения в preview и для FormData
        selectedFiles = currentAttachments.map(att => {
            return {
                name: att.original_filename,
                size: 0,
                type: att.file_type === 'image' ? 'image/jpeg' : (att.file_type === 'video' ? 'video/mp4' : 'application/octet-stream'),
                url: att.file_url,
                id: att.id,
                isExisting: true
            };
        });
        updateAttachmentsPreview();
        scrollToBottom();
        messageInput.focus();
    }

    // Функция для отмены редактирования
    cancelEditButton.onclick = function() {
        editingMessageId = null;
        messageInput.value = '';
        selectedFiles = []; // Очищаем выбранные файлы
        currentAttachments = []; // Очищаем текущие вложения
        updateAttachmentsPreview();
        messageSubmit.textContent = 'Отправить'; // Возвращаем текст кнопки
        cancelEditButton.style.display = 'none'; // Скрываем кнопку отмены
    };

    // Функция для удаления сообщения
    async function deleteMessage(messageId) {
        if (!confirm('Вы уверены, что хотите удалить это сообщение?')) {
            return;
        }

        try {
            // ИСПОЛЬЗУЕМ URL ДЛЯ ГРУППОВЫХ ЧАТОВ
            const response = await fetch(`/chat/${roomType}/${roomId}/delete_message/${messageId}/`, { // ИЗМЕНЕНО
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({})
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            console.log(`Message ${messageId} deleted successfully.`);
        } catch (error) {
            console.error('Error deleting message:', error);
            alert('Ошибка при удалении сообщения: ' + error.message);
        }
    }


    // --- Обработчики отправки сообщений (ОБНОВЛЕННАЯ) ---

    messageSubmit.onclick = async function(e) {
        if (chatSocket.readyState !== WebSocket.OPEN) {
            console.error('WebSocket is not open. Cannot send message.');
            alert('Соединение с чатом не установлено. Пожалуйста, обновите страницу.');
            return;
        }

        const message = messageInput.value.trim();
        if (message === '' && selectedFiles.length === 0) {
            alert('Сообщение не может быть пустым и без вложений!');
            return;
        }

        if (editingMessageId) {
            // Режим редактирования
            await sendEditMessage(message, editingMessageId);
        } else {
            // Режим отправки нового сообщения
            if (selectedFiles.length > 0) {
                await uploadFiles(message);
            } else {
                chatSocket.send(JSON.stringify({
                    'type': 'chat_message',
                    'message': message
                }));
                messageInput.value = '';
                scrollToBottom();
            }
        }
        resetTypingStatus();
        cancelEditButton.click(); // Сбрасываем режим редактирования после отправки/сохранения
    };

    messageInput.onkeyup = function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            messageSubmit.click();
        }
    };

    // Функция для отправки отредактированного сообщения
    async function sendEditMessage(newContent, messageId) {
        const formData = new FormData();
        formData.append('message_content', newContent);

        // Отдельно добавляем существующие вложения (те, которые не были удалены)
        const existingAttachmentIds = selectedFiles
            .filter(file => file.isExisting)
            .map(file => file.id);
        formData.append('existing_attachments', JSON.stringify(existingAttachmentIds));

        // Добавляем новые файлы, которые были выбраны
        selectedFiles.filter(file => !file.isExisting).forEach(file => {
            formData.append('new_files', file);
        });

        try {
            // ИСПОЛЬЗУЕМ URL ДЛЯ ГРУППОВЫХ ЧАТОВ
            const response = await fetch(`/chat/${roomType}/${roomId}/edit_message/${messageId}/`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            console.log('Message edited successfully:', result);

            // Сбрасываем состояние
            editingMessageId = null;
            messageInput.value = '';
            selectedFiles = [];
            currentAttachments = [];
            updateAttachmentsPreview();
            messageSubmit.textContent = 'Отправить';
            cancelEditButton.style.display = 'none';
        } catch (error) {
            console.error('Error editing message:', error);
            alert('Ошибка при редактировании сообщения: ' + error.message);
        }
    }


    // --- Логика загрузки файлов (AJAX) ---

    attachFileButton.onclick = function() {
        fileInput.click();
    };

    fileInput.onchange = function(e) {
        const newFiles = Array.from(e.target.files);
        selectedFiles = selectedFiles.concat(newFiles);
        updateAttachmentsPreview();
    };

    function updateAttachmentsPreview() {
        attachmentsPreview.innerHTML = '';
        if (selectedFiles.length > 0) {
            attachmentsPreview.style.display = 'flex';
        } else {
            attachmentsPreview.style.display = 'none';
        }

        selectedFiles.forEach((file, index) => {
            const previewItem = document.createElement('div');
            previewItem.classList.add('chat_preview-item');

            let fileContent;
            let fileSrc = file.isExisting ? file.url : URL.createObjectURL(file);

            if (file.type.startsWith('image/')) {
                fileContent = document.createElement('img');
                fileContent.src = fileSrc;
                fileContent.classList.add('chat_preview-image');
            } else if (file.type.startsWith('video/')) {
                fileContent = document.createElement('video');
                fileContent.src = fileSrc;
                fileContent.setAttribute('preload', 'metadata');
                fileContent.classList.add('chat_preview-video');
            } else {
                fileContent = document.createElement('i');
                fileContent.classList.add('chat_file-icon', getFileIconClass(file.name));
            }

            const removeButton = document.createElement('span');
            removeButton.classList.add('chat_remove-file');
            removeButton.innerHTML = '&times;';
            removeButton.onclick = () => {
                if (!file.isExisting && fileContent.src.startsWith('blob:')) {
                    URL.revokeObjectURL(fileContent.src);
                }
                selectedFiles.splice(index, 1);
                updateAttachmentsPreview();
            };

            const fileNameSpan = document.createElement('span');
            fileNameSpan.classList.add('chat_file-name');
            fileNameSpan.textContent = file.name;

            previewItem.appendChild(fileContent);
            previewItem.appendChild(removeButton);
            previewItem.appendChild(fileNameSpan);
            attachmentsPreview.appendChild(previewItem);
        });
    }


    function getFileIconClass(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        switch (ext) {
            case 'pdf': return 'fas fa-file-pdf';
            case 'doc':
            case 'docx': return 'fas fa-file-word';
            case 'xls':
            case 'xlsx': return 'fas fa-file-excel';
            case 'txt': return 'fas fa-file-alt';
            case 'zip':
            case 'rar': return 'fas fa-file-archive';
            default: return 'fas fa-file';
        }
    }


    async function uploadFiles(messageText) {
        const formData = new FormData();
        
        // Получаем room_id и roomType из скрытых <script> тегов
        const roomId = JSON.parse(document.getElementById('room-id-data').textContent);
        const roomType = JSON.parse(document.getElementById('room-type-data').textContent); // Это будет "group" или "private"
    
        // ОЧЕНЬ ВАЖНО: передаем оба параметра на сервер
        formData.append('chat_room_id', roomId); // Для Django views.py request.POST.get('chat_room_id')
        formData.append('room_type', roomType);  // Для Django views.py (если вы его используете там)
        formData.append('message_content', messageText);
    
        selectedFiles.forEach(file => {
            formData.append('files', file);
        });
    
        try {
            // ИСПОЛЬЗУЙТЕ УНИВЕРСАЛЬНЫЙ URL для upload_attachment
            // ОН ДОЛЖЕН БЫТЬ ТАКИМ ЖЕ, КАК ВАШ URLPATTERN В urls.py ДЛЯ upload_attachment
            const response = await fetch(`/chat/${roomType}/${roomId}/upload_attachment/`, { // <<< ИЗМЕНЕНИЕ ЗДЕСЬ
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            });
    
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
    
            const result = await response.json();
            console.log('Files upload successful:', result);
    
            selectedFiles = [];
            updateAttachmentsPreview();
            messageInput.value = '';
        } catch (error) {
            console.error('Error uploading files:', error);
            alert('Ошибка при загрузке файлов: ' + error.message);
        } finally {
            resetTypingStatus();
        }
    }

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // --- Скрипт для AJAX-пагинации истории сообщений ---

    let isLoadingMessages = false;
    let hasMoreMessages = true;

    async function loadOldMessages() {
        if (isLoadingMessages || !hasMoreMessages) {
            return;
        }

        isLoadingMessages = true;

        const firstMessageElement = chatLog.querySelector('.chat_message-item');
        const beforeMessageId = firstMessageElement ? firstMessageElement.dataset.messageId : null;

        const loadingIndicator = document.createElement('div');
        loadingIndicator.id = 'loading-indicator';
        loadingIndicator.textContent = 'Загрузка старых сообщений...';
        loadingIndicator.style.textAlign = 'center';
        loadingIndicator.style.padding = '10px 0';
        loadingIndicator.style.color = '#888';
        chatLog.prepend(loadingIndicator);

        const oldScrollHeight = chatLog.scrollHeight;
        const oldScrollTop = chatLog.scrollTop;

        try {
            // ИСПОЛЬЗУЕМ URL ДЛЯ ГРУППОВЫХ ЧАТОВ
            const response = await fetch(`/chat/${roomType}/${roomId}/load_more_messages/?before_message_id=${beforeMessageId}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();

            hasMoreMessages = data.has_more;

            if (data.messages.length > 0) {
                const fragment = document.createDocumentFragment();
                data.messages.forEach(message => {
                    const msgElement = createMessageElement({
                        id: message.id,
                        sender_id: message.sender_id,
                        sender_username: message.sender_username,
                        sender_avatar_url: message.sender_avatar_url,
                        content: message.content,
                        timestamp: message.timestamp,
                        attachments: message.attachments || [],
                        read_count: message.read_count || 0,
                        is_edited: message.is_edited || false
                    });
                    fragment.appendChild(msgElement);
                    addMessageToObserver(msgElement);
                    addMessageActionListeners(msgElement);
                });
                chatLog.insertBefore(fragment, chatLog.firstChild);

                const newScrollHeight = chatLog.scrollHeight;
                chatLog.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);

                if (chatSocket.readyState === WebSocket.OPEN) {
                    observeMessagesForReadReceipts();
                }
            } else {
                hasMoreMessages = false;
                const endOfHistoryIndicator = document.createElement('div');
                endOfHistoryIndicator.textContent = 'Начало истории чата.';
                endOfHistoryIndicator.style.textAlign = 'center';
                endOfHistoryIndicator.style.padding = '10px 0';
                endOfHistoryIndicator.style.color = '#888';
                chatLog.prepend(endOfHistoryIndicator);
            }
        } catch (error) {
            console.error('Ошибка при загрузке старых сообщений:', error);
        } finally {
            if (loadingIndicator.parentNode) {
                loadingIndicator.parentNode.removeChild(loadingIndicator);
            }
            isLoadingMessages = false;
            if (hasMoreMessages && chatLog.scrollTop === 0 && chatLog.scrollHeight <= chatLog.clientHeight) {
                loadOldMessages();
            }
        }
    }

    chatLog.addEventListener('scroll', function() {
        if (chatLog.scrollTop === 0 && !isLoadingMessages && hasMoreMessages) {
            loadOldMessages();
        }
    });

    // Инициализация после загрузки DOM
    document.addEventListener('DOMContentLoaded', () => {
        scrollToBottom();
        addMessageActionListeners(chatLog);
    });

</script>
{% endblock %}